#!/bin/bash
# installOpenObserveGoFlow.sh

VERSION=0.0.1.2026-01-11:0005
echo installOpenObserveGoFlow version $VERSION

# USEREMAIL=""
# USERPASSWORD=""
# APP_HOME_DIR=""

APP_REPO="https://raw.githubusercontent.com/Andrewiski/OpenObserveGoFlowDocker/refs/heads/main/"
USERNAME="${$USER}"
COMPOSE_PROJECT_NAME_1="public.ecr.aws/zinclabs/openobserve:latest"
COMPOSE_PROJECT_NAME_2="openobserve/goflow2:latest"

cliexit() {
    printf '%s\n' "$1" >&2
    exit 1
}

usage() { 
  echo "$0 usage:" && grep " .)\ #" $0; exit 0; 
}

while :; do
    case $1 in
        -useremail) # useremail to install under. 
          if [ "$2" ]; then
            USEREMAIL=$2
            shift
          else
            cliexit 'ERROR: "-useremail" requires a non-empty option argument.'
          fi
          ;;
        
        -userpassword) # user password. 
          if [ "$2" ]; then
              USERPASSWORD=$2
            shift
          else
            cliexit 'ERROR: "--installdir" requires a non-empty option argument.'
          fi
          ;;

		 -installdir) # Install Directory. 
          if [ "$2" ]; then
              APP_DIR=$2
            shift
          else
            cliexit 'ERROR: "--installdir" requires a non-empty option argument.'
          fi
          ;;
       
        -h|-\?|--help) # Display help.
          usage
          exit 0
          ;;
        --)              # End of all options.
            shift
            break
            ;;
        -?*)
            printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2
            ;;
        *)               # Default case: No more options, so break out of the loop.
            break
    esac
  shift
done

set -o nounset
set -o errexit
set -o pipefail

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PATH="${PATH}:/usr/local/bin"
TMP_INSTALL_DIR="${SCRIPT_DIR}"

# prerequisites "command|package"
PREREQUISITES=(
  "curl|curl"
  "sed|sed"
  "envsubst|gettext-base"
)

echo "UserEmail is $USEREMAIL"
echo "App Directoy is $APP_DIR"

if [ "${SCRIPT_DIR}" = "${APP_DIR}" ]; then
  echo >&2 "Please don't run the installation script in the application directory ${APP_DIR}"
  exit 1
fi

cleanup() {
  # Cleanup temp install dir.
  if [ "${TMP_INSTALL_DIR}" != "${SCRIPT_DIR}" ] ; then
    #rm -rf "${TMP_INSTALL_DIR}" || true;
    echo "Cleanup Disabled for now"
  fi
}

fail() {
  echo -e "ERROR: $1" >&2
  cleanup || true;
  exit 1
}

pull_install_files(){
  echo "downloading ${APP_REPO}/dockerCompose/docker-compose.yml"
  echo "curl -LS \"${APP_REPO}/dockerCompose/docker-compose.yml\" -o \"${APP_DIR}/docker-compose.yml\""
	curl -LS "${APP_REPO}/dockerCompose/docker-compose.yml" -o "${APP_DIR}/docker-compose.yml"
}

create_app_folder() {
  mkdir -p -m 770 "${APP_DIR}"
  chown -R "${USERNAME}" "${APP_DIR}" || true
}

write_env_file() {
  echo "Writing env file ${APP_DIR}/app.env"
  cat > "${APP_DIR}/app.env" << EOF
# APP environment variables
# This file is generated by the install script.
# Do not edit this file. Edit the install script instead.
# APP
# The path to the Config Folder where config.json is located
DATADIRECTORY=${APP_DIR}/data
EOF
}

create_data_volumes() {
  volumes=(
    "${APP_DIR}"
    "${APP_DIR}/data"
  )

  for volume in "${volumes[@]}"; do
    echo "Creating volume ${volume}"
    mkdir -p -m u+rwX,g+rw,o-wx "${volume}" || fail "Failed to create volume '${volume}'."
    if [ "${EUID}" -eq 0 ]; then
      chown "${USERNAME}:docker" "${volume}" || fail "Failed to change ownership of '${volume}'."
    fi
  done
}

remove_old_image() {
  local containerName="$1"
  local imageName="$2"
  local currentImage="$(docker ps --format "{{.Image}}" --filter name="^${containerName}$" || true)"
  if [ -z "${currentImage}" ]; then
    return 0;
  fi

  local allImages="$(docker images "${imageName}"* --format "{{.Repository}}:{{.Tag}}" || true)"
  if [ -z "${allImages}" ]; then
    return 0;
  fi

  for value in ${allImages}; do
    if [ "${value}" != "${currentImage}" ]; then
      echo "Removing old image '${value}'"
      if ! docker rmi "${value}"; then
        echo "Failed to remove old image '${value}'"
      fi
   fi
  done
}

get_latest_image() {
    echo "performing docker pull \"${COMPOSE_PROJECT_NAME_1}\""
    docker pull "${COMPOSE_PROJECT_NAME_1}"
	echo "performing docker pull \"${COMPOSE_PROJECT_NAME_2}\""
    docker pull "${COMPOSE_PROJECT_NAME_2}"
}

remove_old_images() {
  echo "Removing old images"
  danglingImages="$(docker images -qf "dangling=true")"
  if [ ! -z "${danglingImages}" ]; then
    echo "Removing dangling images"
    docker rmi ${danglingImages} || true;
  fi
  remove_old_image "${COMPOSE_PROJECT_NAME_1}" "${COMPOSE_CONTAINER_NAME_1}"
  remove_old_image "${COMPOSE_PROJECT_NAME_2}" "${COMPOSE_CONTAINER_NAME_2}"
}



start_docker_containers() {
  echo "Starting docker containers."
  docker compose -p OpenObserveGoFlow --env-file "${APP_DIR}/app.env" -f "${APP_DIR}/docker-compose.yml" up -d openobserve || fail "Failed to start docker containers"
}


confirm_success() {
  echo "Waiting for App to start"
  n=0
  until [ ${n} -ge 10 ]
  do
    sleep 3s
    AppRunning=true
    # env -i is to ensure that http[s]_proxy variables are not set
    # Otherwise the check would go through proxy.
    env -i curl -skL "http://127.0.0.1:5080" > /dev/null && break
    echo "."
    AppRunning=false
    n=$((n+1))
  done

  docker ps

  if [ "${AppRunning}" = true ]; then
    echo "App is running"
  else
    fail "App is NOT running"
  fi
}

# prepare --silent option for curl
curlSilent=""
#if [ "${UNATTENDED}" = "true" ]; then
#  curlSilent="--silent"
#fi

create_app_folder
create_data_volumes
pull_install_files
get_latest_image
write_env_file
start_docker_containers
remove_old_images
confirm_success
exit 0
